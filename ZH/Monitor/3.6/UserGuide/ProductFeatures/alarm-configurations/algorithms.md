# 算法说明

检测算法是通过公式计算数据判断是否符合，符合即为异常点。当前提供了 8 种算法。本篇将介绍每种算法的工作原理，适用的场景和配置的方法。

* 静态阈值
* 同比策略（简易）
* 同比策略（高级）
* 环比策略（简易）
* 环比策略（高级）
* 同比振幅
* 周比区间
* 环比振幅

> 注意： 一种检测算法同级别只能添加一次。

另外如果有AIOps平台将会有另外两种智能算法：

* [单指标智能异常检测](../aiops/aiops_metrics_intelligent_detect.md)
* [单指标智能预测](../aiops/aiops_metrics_forecast.md)


##  算法适用场景概览

针对大部分的固定值类或者变化无周期性变化的可以使用静态阈值。

![-w2021](media/15808205114651.jpg)

针对周期性的曲线，不能以固定的值来进行判断的，可以根据周期特点选择适当的同比算法：

| 周期 | 算法 |
|---|---|
| 周 | 同比策略（简易）|
| 日 | 同比策略（高级），同比区间，同比振幅 |

不能以固定的值来进行判断，针对实时突增突降需求，可以选择环比算法：
- 环比策略（简易）
- 环比策略（高级）
- 环比振幅

1. 温水煮青蛙型 - 数据缓慢上升或下降使用 【同比区间】

![-w2021](media/15807168374571.jpg)

2. 突然爆发型 – 数据出现 5 分钟陡升或陡降 使用 【环比策略】或 【同比振幅】

![-w2021](media/15807168458438.jpg)

3. 水平限制型 – 数据不能上升或下降到某个数值 使用 【环比区间】

![-w2021](media/15807168553132.jpg)

## 具体检测算法说明

### 静态阈值

静态阈值是最简单也是使用最普遍的检测算法，只要值满足条件即为异常。是一种固定的设定方法。大多数的都是以静态阈值为主。

![-w2021](media/15808205114651.jpg)

#### 适用场景

适用于许多场景，适用可以通过固定值进行异常判断的。如磁盘使用率检测，机器负载等。

#### 配置方法

![-w2021](media/15730238076864.jpg)

#### 实现原理

```python
{value} {method} {threshold}

# value：当前值
# method：比较运算符(=，>， >=， <， <=, !=)
# threshold： 阈值
# 当前值 (value) 和阈值 (threshold) 进行比较运算

多条件时，使用and或or关联。 判断规则：or 之前为一组
例：
>= 10 and <= 100 or = 0 or >= 120 and <= 200
(>= 10 and <= 100) or (= 0)  or (>= 120 and <= 200)
```

### 同比策略（简易）/同比策略（高级）

#### 适用场景

适用于以周为周期的曲线场景。比如 pv、在线人数等

#### 配置方法

####  实现原理

* 同比策略（简易）

```python
{value} >= {history_value} * (100 + ceil) * 0.01)
or
{value} <= {history_value} * (100 - floor) * 0.01)

# value：当前值
# history_value：上周同一时刻值
# ceil：升幅
# floor：降幅
# 当前值(value) 与上周同一时刻值 (history_value)进行升幅/降幅计算

```

- 示例：当 value(90)，ceil(100)，history_value(40)时，则判断为异常

* 同比策略（高级）

```python
# 算法原理和同比策略（简易）一致，只是用来做比较的历史值含义不一样。
{value} >= {history_value} * (100 + ceil) * 0.01)
or
{value} <= {history_value} * (100 - floor) * 0.01)

# value：当前值
# history_value：前n天同一时刻绝对值的均值
# ceil：升幅
# floor：降幅
# 当前值(value) 与前n天同一时刻绝对值的均值 (history_value)进行升幅/降幅计算

# 前n天同一时刻绝对值的均值计算示例
以日期2019-08-26 12:00:00为例，如果n为7，历史时刻和对应值如下：
```

||时间|值|
|---|---|---|
|1  |2019-8-25 12:00:00 | 12  |
|2  |2019-8-24 12:00:00 | -22 |
|3  |2019-8-23 12:00:00 | 32  |
|4  |2019-8-22 12:00:00 | 42  |
|5  |2019-8-21 12:00:00 | 52  |
|6  |2019-8-20 12:00:00 | 62  |
|7  |2019-8-19 12:00:00 | 72  |

```python
取绝对值，因此所有的值为正数
history_value = (12 + 22 + 32 + 42 + 52 + 62 +72) / 7 = 42
```

- 示例：当 value(90)，ceil(100)，history_value(42)时，则判断为异常

### 环比策略（简易）/环比策略（高级）

#### 适用场景

- 适用于需要检测数据陡增或陡降的场景。如交易成功率、接口访问成功率等

#### 配置方法

#### 实现原理

* 环比策略（简易）

```python
# 算法原理和同比策略（简易）一致，只是用来做比较的历史值含义不一样。
{value} >= {history_value} * (100 + ceil) * 0.01)
or
{value} <= {history_value} * (100 - floor) * 0.01)

# value：当前值
# history_value：前一时刻值
# ceil：升幅
# floor：降幅
# 当前值(value) 与前一时刻值 (history_value)进行升幅/降幅计算

```

- 示例：当 value(90)，ceil(100)，history_value(40)时，则判断为异常
- 场景：适用于需要检测数据陡增或陡降的场景。如交易成功率、接口访问成功率等

* 环比策略（高级）

- 实现原理：

```python
# 算法原理和同比策略（简易）一致，只是用来做比较的历史值含义不一样。
{value} >= {history_value} * (100 + ceil) * 0.01)
or
{value} <= {history_value} * (100 - floor) * 0.01)

# value：当前值
# history_value：前n个时间点的均值
# ceil：升幅
# floor：降幅
# 当前值(value) 与前个时间点的均值 (history_value)进行升幅/降幅计算

# 前n个时间点的均值计算示例（数据周期1分钟）
以日期2019-08-26 12:00:00为例，如果n为5，历史时刻和对应值如下：
```

||时间|值|
|---|---|---|
|1  |2019-8-26 11:59:00 | 12  |
|2  |2019-8-26 11:58:00 | 22  |
|3  |2019-8-26 11:57:00 | 32  |
|4  |2019-8-26 11:56:00 | 42  |
|5  |2019-8-26 11:55:00 | 52  |

```python
history_value = (12 + 22 + 32 + 42 + 52) / 5 = 32
```

- 示例：当 value(90)，ceil(100)，history_value(32)时，则判断为异常

### 同比振幅

#### 适用场景

- 场景：适用于监控以天为周期的事件，该事件会明确导致指标的升高或者下降，但需要监控`超过合理范围幅度变化`的场景。

    比如每天上午 10 点有一个抢购活动，活动内容不变，因此请求量每天 10:00 相比 09:59 会有一定的升幅。因为活动内容不变，所以请求量的升幅是在一定范围内的。使用该策略可以发现异常的请求量。

#### 配置方法

![-w2021](media/15730233179624.jpg)

#### 工作原理

```python
# 算法示例：
当前值 − 前一时刻值 >= 过去 5 天内任意一天同时刻差值 × 2 + 3

以日期2019-08-26 12:00:00为例，如果n为5，历史时刻和对应值如下：
```

||时间|值|前一时刻|前一时刻值|差值|
|---|---|---|---|---|---|
|0  |2019-8-26 12:00:00 | 26  |2019-8-26 11:59:00 | 10  |16|
|1  |2019-8-25 12:00:00 | 25  |2019-8-25 11:59:00 | 18  |7 |
|2  |2019-8-24 12:00:00 | 24  |2019-8-24 11:59:00 | 30  |6 |
|3  |2019-8-23 12:00:00 | 23  |2019-8-23 11:59:00 | 31  |8|
|4  |2019-8-22 12:00:00 | 22  |2019-8-22 11:59:00 | 32  |10|
|5  |2019-8-21 12:00:00 | 21  |2019-8-21 11:59:00 | 33  |12|

```python
# 当前值
value = 26
# 前一时刻值
prev_value = 10
# 比较运算符(=，>， >=， <， <=, !=)
method = ">="
# 波动率
ratio = 2
# 振幅
shock = 3
# 当前值一前一时刻值的差值
current_diff = 16
# 5天内同时刻差值
prev5_diffs = [7, 6, 8, 10, 12]

前第二天(2019-8-24)同时刻差值： 6 * ratio(2) + shock(3) = 15
current_diff(16) >= 15

# 当前值(26) - 前一时刻值(10) >= 2天前的同一时刻差值6 * 2 + 3
此时算法检测判定为检测结果为异常：
```

### 同比区间

#### 适用场景

温水煮青蛙型 - 数据缓慢上升或下降

![-w2021](media/15807168374571.jpg)

适用于以天为周期的曲线场景。

由于该模型中数据是缓慢变化的，所以使用【环比策略】、【同比振几幅】都检测不出告警，因为这两种模型主要使用于突升、突降、大于或小于指定值的情况。

【同比区间】才适用于这种情况，因为随着数据的变化，当前值和模型值差距越来越大，而区间比较主要就是那当前值和历史模型值做比较。

#### 配置方法

![-w2021](media/15892524354204.jpg)

#### 工作原理

- 实现原理&示例：

```python
# 算法示例：
当前值 >= 过去 5 天内同时刻绝对值 × 2 + 3

以日期2019-08-26 12:00:00为例，如果n为5，历史时刻和对应值如下：
```

||时间|值|
|---|---|---|
|0  |2019-8-26 12:00:00 | 26  |
|1  |2019-8-25 12:00:00 | 16  |
|2  |2019-8-24 12:00:00 | 14  |
|3  |2019-8-23 12:00:00 | 13  |
|4  |2019-8-22 12:00:00 | 16  |
|5  |2019-8-21 12:00:00 | 15  |

```python
# 当前值
value = 11
# 比较运算符(=，>， >=， <， <=, !=)
method = ">="
# 波动率
ratio = 2
# 振幅
shock = 3

前第3天(2019-8-23)同时刻值： 13 * ratio(2) + shock(3) = 26
value(26) >= 26

# 当前值(26) >= 3天前的同一时刻绝对值13 * 2 + 3
此时算法检测判定为检测结果为异常：
```

### 环比振幅

#### 适用场景

- 适用于指标陡增或陡降的场景，如果陡降场景，ratio(波动率)配置的值需要 < -1
- 该算法将环比算法自由开放，可以通过配置 波动率 和 振幅，来达到对数据陡变的监控。同时最小阈值可以过滤无效的数据

#### 配置方法

![-w2021](media/15892523996558.jpg)

#### 工作原理

```python
# 当前值(value) 与前一时刻值 (prev_value)均>= (threshold)，且之间差值>=前一时刻值 (prev_value) * (ratio) + (shock)

# value：当前值
# prev_value：前一时刻值
# threshold：阈值下限
# ratio：波动率
# shock：振幅

以日期2019-08-26 12:00:00为例：
```

||时间|值|
|---|---|---|
| 0 |2019-8-26 12:00:00 | 46  |
| 1 |2019-8-26 11:59:00 | 12  |


```python
# 当前值
value = 46
# 前一时刻值
prev_value = 12
# 波动率
ratio = 2
# 振幅
shock = 3

value(46) >= 10  and prev_value(12) >=10
value(46) >= prev_value(12) * (ratio(2) + 1) + shock(3)

此时算法检测判定为检测结果为异常：
# 当前值(46)与前一时刻值(12)均>= (10)，且之间差值>=前一时刻值 (12) * (2) + (3)
```

## 内置特殊检测算法

内置特殊算法无需配置，默认绑定对应的指标。

### 系统重启

![](media/16621299662664.jpg)

内置检测算法：基于时序数据 system.env.uptime 进行判断。

```python
# 主机运行时长在0到600秒之间
# 主机当前运行时长比前一周期值小，或者前一个周期值为空
```

### 进程端口

![](media/16621300201982.jpg)


内置检测算法：基于时序数据 system.proc_port.exists 及 nonlisten，not_accurate_listen 判断

```python
# exists != 1 进程不存在
# nonlisten != [] 端口不存在
# not_accurate_listen != [] 进程存在，但端口和cmdb注册端口不一致
```

## 日志关键字检测算法

仅支持静态阈值


