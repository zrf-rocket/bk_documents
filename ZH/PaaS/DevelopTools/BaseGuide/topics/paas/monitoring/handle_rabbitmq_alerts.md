# 当出现 RabbitMQ 告警该怎么处理

## RabbitMQ 队列堆积

该告警出现时，说明生产者和消费者速度不匹配，大量消息不能及时处理，导致在队列中堆积，首先需要检查消费者：

1. 消费者是否未启动或卡死？
2. 消费者的消费速度是否过慢？

当出现情况 1 时，请排查代码是否有 bug，比如 celery worker 未启动，代码中存在死锁问题。出现情况 2 时，请检查代码中是否大量有长时间阻塞的操作，比如等待，轮询第三方等动作。平台对每个进程都提供了实例数调整的功能，可以合理增加实例数来增加消费能力，同时也建议优化代码逻辑。
再者，需要检查下生产者：

1. 消息投递的速度是否过快？
2. 是否投递了不合法的消息，导致消费者无法处理？

情况 1 出现时，需要优化代码逻辑，以保证生产者和消费者速度的匹配。消费者收到不能处理的消息，可能会进行重新入队列的操作，出现了情况 2 的问题，这个时候也需要修改代码。

## RabbitMQ 队列消息使用量过多

队列消息的持续堆积可能最终会影响集群的稳定性，因此每个队列都做了资源限制，当队列长度将要触达了限制长度时，会触发这个告警。

收到该告警时，请马上进行处理，避免因达到队列长度限制导致数据的丢失。

## RabbitMQ 服务异常

该告警是 RabbitMQ 服务自检失败时产生的，RabbitMQ 服务自检步骤如下：

1. 创建 *aliveness-test* 队列；
2. 进行默认的路由绑定；
3. 进行消息的投递消费测试；

以上任意一个步骤失败都表示着自检失败，一般来说自检失败都代表着服务异常，但是有一些额外的情况需要注意：

1. 用户使用不兼容参数创建了同名的队列；
2. 用户删除了自检队列；
3. 用户创建的队列已达到了资源上限，导致自检队列无法创建；

当收到告警时，可以尝试进入增强服务的控制台检查是否存在上述的情况，没有请联系 BK 助手。

## RabbitMQ 服务消息丢弃

收到该告警时，说明有消息被丢弃进了死信队列 *dlxqueue* 。*dlx.queue* 是默认的死信队列，相当于其他队列的消息“回收站”，专门回收其他队列丢弃的消息，增加了数据安全性。

### 队列为什么会丢弃消息

当出现以下三种情况时，消息会被丢弃：

1. 队列消息过期；
2. 原有队列消息超长，并且 overflow 设置成 drop-head，导致的头部消息丢弃；
3. 消费者拒绝；

如果没有死信队列，这些消息会被直接删除，无法恢复。

### 如何避免消息丢弃

首先消费者及时消费，避免消息过期，同时保持生产者和消费者速度上的匹配，避免消息超长堆积，或者 overflow 设置成 reject-publish，合理阻塞生产者；
对于消费者拒绝消息的情况，需要检查应用代码，一般是因为以下情况导致：

1. 消费者处理异常;
2. 生产者投递了异常消息；

第二种情况较为常见，比如一些使用了 celery beat 的应用，可能因为数据库的脏数据导致调度了一个不存在的任务，这类的消息会持续被 worker 拒绝；